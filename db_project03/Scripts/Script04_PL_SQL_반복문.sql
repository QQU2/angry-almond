/* PL/SQL(RPOCEDURAL LANGUAGE/SQL)
 * - 프로그래밍 기능이 추가된 SQL
 * - 변수정의, 조건문, 반복문을 만들어 SQL문에 대한 처리 가능
 * - 유형: PROCEDUR/ USER DEFINED FUNCTION(사용자 정의 함수)/ TRIGGER
 * - BLOCK 구조
 *		HEADER: 기본 정보
 * 	 	IS
 *			DECLARATION SECTION: 선언
 *  	BEGIN
 * 			EXECUTION: 실제 연산처리
 * 			EXCEPTION SECTION: 예외처리
 *   	END;
 * 		/
 */
--SET SEVEROUTPUT IN;
DECLARE --변수 선언부 영역

BEGIN --로직 작성 영역
	DBMS_OUTPUT.PUT_LINE('Hello PL/SQL')

EXCEPTION --예외 처리 영역
END;


--<예제 1> 변수 그냥 정의(숫자)
DECLARE 
	x NUMBER;
	y NUMBER := 0;
	z CONSTANT NUMBER := 20; --상수
BEGIN 
	x := 10;
	--에러남 -> z := 30;
	DBMS_OUTPUT.PUT_LINE('변수 x ->' || x);
	DBMS_OUTPUT.PUT_LINE('변수 y ->' || y);
	DBMS_OUTPUT.PUT_LINE('상수 z ->' || z);
END;


--<예제 2> 변수 그냥 정의(글자)
DECLARE
 	STR VARCHAR2(10); -- 가변 문자열 크기지정 필수
BEGIN
	STR := 'Hello';
	DBMS_OUTPUT.PUT_LINE(STR);
END;


--<예제 3> 변수 자료형 원래 테이블에서 가져오기(%TYPE)
-- 한 개의 행만 가져올 수 있음 
DECLARE
	--		 ↓ 원래 테이블의 컬럼 타입을 가져옴(테이블명.컬럼명 + %TYPE)	
	EMP_ID 	 EMPLOYEES.EMPLOYEE_ID%TYPE;
	EMP_NAME EMPLOYEES.FIRST_NAME%TYPE;
BEGIN
	SELECT EMPLOYEE_ID, FIRST_NAME
	  INTO EMP_ID, 		EMP_NAME --순서대로 저장됨
	FROM EMPLOYEES 
	WHERE EMPLOYEE_ID = 100;
	DBMS_OUTPUT.PUT_LINE(EMP_ID ||'/'|| EMP_NAME);
END;


--<예제 4> 변수 자료형 원래 테이블에서 가져오기(%ROWTYPE)
-- 한 개의 행만 가져올 수 있음 
DECLARE
	--	 ↓ 원래 테이블을 한 개의 행 단위로 참조
	EMP_ID	 EMPLOYEES%ROWTYPE;
BEGIN
	SELECT *
	  INTO EMP_ID
	FROM EMPLOYEES 
	WHERE EMPLOYEE_ID = 110;
--	WHERE EMPLOYEE_ID > 110; 에러남-> 너무 많은 수의 행이 추출되기 때문
	DBMS_OUTPUT.PUT_LINE(EMP_ID.EMPLOYEE_ID ||'/'|| EMP_ID.FIRST_NAME);
	DBMS_OUTPUT.PUT_LINE(EMP_ID.SALARY ||'만원');
END;

/** LOOP~LOOP END;**/ 
--대부분 IF절과 함께 쓰임(끝낼 타이밍 제시)
/** IF ~ ELSE/ELSIF ~ END IF **/
DECLARE
	EMP_ID	 EMPLOYEES%ROWTYPE;
	ID NUMBER := 100;
BEGIN
	LOOP
		SELECT *
		  INTO EMP_ID
		FROM EMPLOYEES 
		WHERE EMPLOYEE_ID = ID;
		DBMS_OUTPUT.PUT_LINE(EMP_ID.EMPLOYEE_ID ||'/'|| EMP_ID.FIRST_NAME);
		DBMS_OUTPUT.PUT_LINE('연봉 '|| EMP_ID.SALARY ||'만원');
		
		ID := ID + 1;
		IF(ID >= 150) THEN EXIT;
		END IF;
	
	END LOOP;
END;

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES e ORDER BY EMPLOYEE_ID ;
SELECT EMPLOYEE_ID, FIRST_NAME, PHONE_NUMBER FROM EMPLOYEES e 
WHERE PHONE_NUMBER LIKE '650%' ORDER BY EMPLOYEE_ID ;
SELECT * FROM LOCATIONS l ;
SELECT * FROM EMPLOYEES e ;

DECLARE
	EMP	 EMPLOYEES%ROWTYPE;
	--증감을 위한 변수
	ID NUMBER := 100;
BEGIN
	LOOP
		SELECT *
		  INTO EMP
		FROM EMPLOYEES 
		WHERE EMPLOYEE_ID = ID;
		
		IF(NVL(EMP.COMMISSION_PCT, 0) = 0) THEN 
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID ||'/ 1: '|| EMP.SALARY);
		ELSIF(NVL(EMP.COMMISSION_PCT, 0) > 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID ||'/ 2: '|| EMP.SALARY * (1 + EMP.COMMISSION_PCT));
		END IF;
		
		ID := ID + 1;
		IF(ID >= 150) THEN EXIT;
		END IF;
	END LOOP;
END;

SELECT EMPLOYEE_ID, COMMISSION_PCT  FROM EMPLOYEES e ORDER BY EMPLOYEE_ID;


/**FOR ... IN ...LOOP **/
--FOR문을 사용한다면 DECLARE에다가 증감을 위한 변수명 선언 안해도 됨
-- 또한 증가식, 감소식 써주지 않아도 됨
DECLARE
	EMP	 EMPLOYEES%ROWTYPE;
	--증감을 위한 변수 없음
BEGIN
	FOR ID IN REVERSE 100..150 LOOP --REVERSE는 거꾸로 조회/ 숫자 100과 150 사이 ..은 꼭 2개여야 함
		SELECT *
		  INTO EMP
		FROM EMPLOYEES 
		WHERE EMPLOYEE_ID = ID;
		
		IF(NVL(EMP.COMMISSION_PCT, 0) = 0) THEN 
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID ||'/ 1: '|| EMP.SALARY);
		ELSIF(NVL(EMP.COMMISSION_PCT, 0) > 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID ||'/ 2: '|| EMP.SALARY * (1 + EMP.COMMISSION_PCT));
		END IF;
		
	END LOOP;
END;

/** WHILE ...LOOP**/
DECLARE
	EMP	 EMPLOYEES%ROWTYPE;
	--증감을 위한 변수 초기화 필요
	ID NUMBER := 100;
BEGIN
	WHILE ID < 150 LOOP 
		SELECT *
		  INTO EMP
		  FROM EMPLOYEES 
	  	 WHERE EMPLOYEE_ID = ID;
		 
		IF(NVL(EMP.COMMISSION_PCT, 0) = 0) THEN 
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID ||'/ 1: '|| EMP.SALARY);
		ELSIF(NVL(EMP.COMMISSION_PCT, 0) > 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID ||'/ 2: '|| EMP.SALARY * (1 + EMP.COMMISSION_PCT));
		END IF;
		ID := ID + 1;
	END LOOP;
END;


BEGIN 
	FOR CHARACTER1 IN '1'..'10' LOOP
		DBMS_OUTPUT.PUT_LINE(CHARACTER1);
	END LOOP;
END;
 