/*** 1. 사용자 정의 TYPE(RECORD TYPE) */
-- %ROWTYPE은 SELECT절에서 *로만 조회 가능하게 함
-- 사용자 정의 TYPE은 SELECT절에서 원하는 컬럼을 조회할 수 있음
-- 하지만 %ROWTYPE처럼 하나의 행만 WHERE절에서 조회가능
--설정한 레코드 타입에 넣고 바로 출력하는 형식

DECLARE
    TYPE MY_TYPE_RECORD IS RECORD (
         ID        EMPLOYEES.EMPLOYEE_ID%TYPE
       , FNAME     EMPLOYEES.FIRST_NAME%TYPE
       , LNAME     EMPLOYEES.LAST_NAME%TYPE
       , SALARY    EMPLOYEES.SALARY%TYPE
       , DEPT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE
    );
    
    RECORD_DATA    MY_TYPE_RECORD;
BEGIN
	SELECT E.EMPLOYEE_ID
	     , E.FIRST_NAME
	     , E.LAST_NAME
	     , E.SALARY
	     , D.DEPARTMENT_NAME
	  INTO RECORD_DATA
	  FROM EMPLOYEES E JOIN DEPARTMENTS D
	    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
	 WHERE E.EMPLOYEE_ID = 100;
	
	DBMS_OUTPUT.PUT_LINE(RECORD_DATA.ID);
    DBMS_OUTPUT.PUT_LINE(RECORD_DATA.FNAME);
    DBMS_OUTPUT.PUT_LINE(RECORD_DATA.LNAME);
    DBMS_OUTPUT.PUT_LINE(RECORD_DATA.SALARY);
    DBMS_OUTPUT.PUT_LINE(RECORD_DATA.DEPT_NAME);
END;
	
SELECT * FROM DEPARTMENTS;


/*** 2. TABLE TYPE ***/
-- 테이블 타입 배열이라고 생각하면 됨
-- 테이블 타입의 배열에 일단 저장해 놓고 출력하는 형식(저장 따로, 출력 따로)

--<예제 1>--
DECLARE
  --TYPE 테이블명	   	   IS TABLE OF 테이블명.컬럼%자료형(배열의 자료형)  INDEX BY 배열에 접근하기 위한 인덱스의 자료형;
    TYPE MY_TYPE_TABLE IS TABLE OF EMPLOYEES.EMPLOYEE_ID%TYPE INDEX BY BINARY_INTEGER;
    TABLE_DATA    MY_TYPE_TABLE;
    IDX 	NUMBER := 1;
BEGIN
	--배열 D를 만들어 TABLE_DATA 에 넣음
	FOR D IN (SELECT EMPLOYEE_ID FROM EMPLOYEES) LOOP
		TABLE_DATA(IDX) := D.EMPLOYEE_ID;
		IDX := IDX + 1;
	END LOOP;

	--TABLE_DATA에서  결과값 추출
	FOR I IN 1..TABLE_DATA.COUNT LOOP
		DBMS_OUTPUT.PUT_LINE(TABLE_DATA(I));
	END LOOP;
END;

--<예제 2>--
DECLARE
    TYPE MY_TYPE_TABLE IS TABLE OF EMPLOYEES%ROWTYPE INDEX BY BINARY_INTEGER;
    TABLE_DATA    MY_TYPE_TABLE;
   IDX 	NUMBER := 1;
BEGIN
	FOR D IN (SELECT * FROM EMPLOYEES) LOOP
		TABLE_DATA(IDX) := D;
		IDX := IDX + 1;
	END LOOP;
	FOR I IN 1..TABLE_DATA.COUNT LOOP
		DBMS_OUTPUT.PUT_LINE(TABLE_DATA(I).EMPLOYEE_ID);
	END LOOP;
END;


/*** 믹스 믹스 ***/

--1. 유저레코드 + 테이블 레코드
DECLARE
    TYPE MY_TYPE_RECORD IS RECORD (
         ID        EMPLOYEES.EMPLOYEE_ID%TYPE
       , FNAME     EMPLOYEES.FIRST_NAME%TYPE
       , LNAME     EMPLOYEES.LAST_NAME%TYPE
       , SALARY    EMPLOYEES.SALARY%TYPE
       , DEPT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE
    );
   
   TYPE MY_TYPE_TABLE IS TABLE OF MY_TYPE_RECORD INDEX BY BINARY_INTEGER;
    TABLE_DATA    MY_TYPE_TABLE;
    IDX 	NUMBER := 1;
BEGIN
	--배열 D를 만들어 TABLE_DATA 에 넣음
	FOR D IN (SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.SALARY, D.DEPARTMENT_NAME 
				FROM EMPLOYEES E 
				JOIN DEPARTMENTS D ON E.EMPLOYEE_ID = D.DEPARTMENT_ID) LOOP
		TABLE_DATA(IDX) := D;
		IDX := IDX + 1;
	END LOOP;

	--TABLE_DATA에서  결과값 추출
	FOR I IN 1..TABLE_DATA.COUNT LOOP
		DBMS_OUTPUT.PUT_LINE(TABLE_DATA(I).ID);
	END LOOP;
END;

--2. 사원이름 출력
DECLARE
    TYPE MY_TYPE_RECORD IS RECORD (
         ID        EMPLOYEES.EMPLOYEE_ID%TYPE
       , FNAME     EMPLOYEES.FIRST_NAME%TYPE
       , LNAME     EMPLOYEES.LAST_NAME%TYPE
       , SALARY    EMPLOYEES.SALARY%TYPE
       , DEPT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE
    );
   
	TYPE MY_TYPE_TABLE IS TABLE OF MY_TYPE_RECORD INDEX BY BINARY_INTEGER;
    TABLE_DATA    MY_TYPE_TABLE;
    IDX 	NUMBER := 1;
BEGIN
	--배열 D를 만들어 TABLE_DATA 에 넣음
	FOR D IN (SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.SALARY, D.DEPARTMENT_NAME 
				FROM EMPLOYEES E 
				JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID) LOOP
		TABLE_DATA(IDX) := D;
		IDX := IDX + 1;
	END LOOP;
	
	IDX:= TABLE_DATA.FIRST;
	WHILE(IDX IS NOT NULL) LOOP
		DBMS_OUTPUT.PUT_LINE(TABLE_DATA(IDX).FNAME);
		IDX := TABLE_DATA.NEXT(IDX);
	END LOOP;
	

	/*
	FOR I IN 1..TABLE_DATA.COUNT LOOP
		DBMS_OUTPUT.PUT_LINE(TABLE_DATA(I).ID);
	END LOOP;
	*/
END;